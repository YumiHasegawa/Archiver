Задание:

Написать программу на C#, предназначенную для сжатия и расжатия файлов с
помощью System.IO.Compression.GzipStream.
Параметры программы, имена исходного и результирующего файлов задаются в
командной строке следующим образом:
 для архивации: GZipTest.exe compress [имя исходного файла] [имя архива]
 для разархивации: GZipTest.exe decompress  [имя архива] [имя распакованного
файла]
В случае успеха программа возвращает 0, при ошибке  1.
Программа должна эффективно распараллеливать и синхронизировать задачи в
многопроцессорной среде и уметь обрабатывать файлы, размер которых превышает объем
доступной оперативной памяти.
Код должен корректно обрабатывать все исключения, а при работе с потоками
допускается использовать только стандартные классы и библиотеки из .Net 3.5 (исключая
ThreadPool, BackgroundWorker, TPL). Ожидается реализация с использованием Thread-ов.
Код программы должен следовать принципам ООП и ООД (читаемость, разбиение
на классы и тд).
Алгоритм работы программы необходимо описать словами.
Исходники необходимо прислать вместе с проектом Visual Studio.
Дополнительным плюсом будет возможность корректной остановки программы по
Ctrl-C.

Описание работы:

Начало работы

1.	Валидация входных параметров (Program.cs, вызов: 16 строка, функция: 35 строка).
При запуске программы пользователь указывает нужную операцию, исходный файл, над которым 
будет произведена операция, и конечный файл, в который будет производиться запись. 
Параметры задаются следующим образом:
•	для архивации: GZipTest compress [имя исходного файла] [имя архива]
•	для разархивации: GZipTest decompress  [имя архива] [имя распакованного файла]
Функция Validation() проверяет правильность ввода параметров и вызывает исключение если:
•	если число указанных параметров не равно 3;
•	если была неверно указана операция;
•	если исходного файла не существует;
•	если у исходного и конечного файлов одинаковые имена;  
•	если исходный файл весит 0 байт;
•	если файл уже был сжат (compress для .gz);
•	если неверно указано расширение архива (.gz);
•	если архив весит меньше 13 байт (12 байт на сигнатуру).

2.	Создание объекта производного класса (Program.cs, 19 строка).
Объект создается в зависимости от указанной операции.

if (args[0].ToLower() == "compress")
gzipabstract = new Compression(args[1], args[2]);
else
gzipabstract = new Decompression(args[1], args[2]);

3.	GzipAbstract (GzipAbstract.cs).
Это абстрактный класс, который предоставляет базовый функционал для 
двух классов-наследников — Compression и Decompression.
Абстрактные свойства:
•	returnValue — значение, необходимое для завершения программы;
•	bufferSize — размер буфера для работы с файлами; 
•	readQueue — экземпляр класса Queue, необходимый для чтения из исходного файла;
•	writeQueue — экземпляр класса Queue, необходимый для записи в итоговый файл;
•	sourceFile — имя исходного файла;
•	resultFile — имя итогового файла;
•	threads — количество потоков для сжатия и разжатия информации (определяется в зависимости от 
количества процессоров на запускаемом ПК);
•	exitThread — массив событий для отслеживания работы потоков для сжатия и разжатия информации. 
Абстрактные методы:
•	Execute() — начало выполнения указанной операции (Program.cs, вызов: 23 строка);
•	Read() — чтение из исходного файла;
•	Write() — запись в итоговый файл.

4.	ByteBlocks (ByteBlocks.cs)
С помощью этого класса при чтении и выполнении сжатия / разжатия создаются объекты, которые хранят в себе:
buffer (byte[]) — массив байтов, который был считан из исходного файла или созданный в процессе выполнения операции.
id (int) — порядковый номер (позиция массива байтов в исходном файле).
Методы getId() и getBuffer() возвращают значения id и buffer соответственно.

5.	Queue (Queue.cs)
С помощью этого класса организуется очередь объектов класса ByteBlocks. В абстрактном классе создается 
2 экземпляра этого класса — readQueue и writeQueue, предназначенные для чтения и записи массивов байтов 
из объектов ByteBlocks соответственно. 
Аттрибуты класса:
•	closeQueue — булевая переменная, показывающая, открыты или закрыты readQueue и  writeQueue;
•	idCount — счетчик id, необходимый для обработки объектов последовательно (по их id);
•	queueByteBlocks — очередь объектов;
•	maxObjects — максимальное количество объектов, добавляемых в очередь для последующей работы с ними. 
Объекты, которые не могут быть добавлены в очередь, находятся в состоянии ожидания (Monitor.Wait(queueByteBlocks));
•	queueCount — количество объектов в queueByteBlocks. Значение переменной не может быть больше maxObjects.
Методы класса:
•	Close() — закрытие readQueue и  writeQueue (изменение значения переменной closeQueue);
•	AddToQueue() — добавление объекта в очередь queueByteBlocks;
•	DeleteFromQueue() — удаление объекта из очереди queueByteBlocks.

Сжатие 

Выполнение сжатия начинается с запуска метода Execute() (Compression.cs)
Этот метод  одновременно запускает несколько потоков:
•	readThread — поток чтения исходного файла (метод Read()), создания объектов ByteBlocks, 
содержащие в себе массивы считанных байтов, и помещение их в очередь readQueue. 
Когда поток завершает работу, readQueue переходит в состояние closed.
•	compressionThreads — потоки сжатия объектов ByteBlocks, взятых из readQueue (метод Compress()). 
Их число равно значению переменной threads, объявленной в абстрактном методе. 
Во время компрессии создаются новые объекты ByteBlocks, содержащие в себе тот же id, но новый массив 
байтов, и добавляются в очередь writeQueue. Исходные объекты считаются ненужными и удаляются из памяти 
сборщиком мусора.
•	writeThread — поток записи конечного файла с использованием сериализации (сохранение объектов вместе с их данными) 
последовательности объектов ByteBlocks из writeQueue (метод Write()).
К каждому compressionThreads присваивается событие ManualResetEvent (exitThread) в несигнальном состоянии. 
Метод WaitHandle.WaitAll(exitThread) (Compression.cs, 39 строка) ожидает завершения работы потоков, 
приостанавливая работу основного потока (программы). Когда потоки заканчивают компрессию, они вызывают 
событие .Set() (Compression.cs, строка 84), переводя событие в сигнальное состояние. Когда все потоки 
завершены, writeQueue переходит в состояние closed.
Далее основной поток (программа), ожидает завершения потока writeThread.

Разжатие

Алгоритм декомпрессии не особо отличается от алгоритма сжатия.
В методе Read() данные из исходного файла десериализуются, а полученные объекты помещаются в readQueue.
В методе Write() массивы байтов, находящиеся в объектах из writeQueue, последовательно записываются в файл.

Конец работы

В Program.cs мы вызываем метод ReturnValue, который вернет значение переменной returnValue, объявленной 
в абстрактном методе. В случае успеха это значение будет равно 0, а неудачи — 1. 
